#include <ESP32Encoder.h>
#include <ESP32Servo.h>
#include <WiFi.h>
#include <ESPmDNS.h>
#include <AsyncTCP.h>
#include <HardwareSerial.h>
#include <math.h>
#include <Arduino.h>
#include <Wire.h>


const int motorA_EN = 25;
const int motorA_IN1 = 26;
const int motorA_IN2 = 27;
const int motorB_EN = 33;
const int motorB_IN1 = 32;
const int motorB_IN2 = 14;
const int freqPWM = 20000;
const int resPWM = 8; 
int valSpeed = 200;    // Basisgeschwindigkeit
int pwmA = 196;        // aktuelle PWM für Motor A
int pwmB = 200;  
int i = 0;


const int servoPin1 = 2;
const int servoPin2 = 4;
const int servoPin3 = 13;

const int ENCA_1 = 23;
const int ENCA_2 = 5;
const int ENCB_1 = 19;
const int ENCB_2 = 18;
ESP32Encoder encA, encB;

int64_t cA = 0;
int64_t cB = 0;

bool inTurn = true;

unsigned long lastRunTime = 0;    // speichert den letzten Ausführungszeitpunkt
const unsigned long interval = 5000; // 5 Sekunden (5000 ms)

double tol = 0.000; 
int state = 0;      // 0=Norden, 1=Osten, 2=Süden, 3=Westen

int target = 0;
const int NUM_WP = 1;

¡
void setSpeedClamped(int vA, int vB){
  vA = constrain(vA, 0, 255);
  vB = constrain(vB, 0, 255);
  ledcWrite(motorA_EN, vA);
  ledcWrite(motorB_EN, vB);
}

void forward() {
  digitalWrite(motorA_IN1, HIGH);
  digitalWrite(motorA_IN2, LOW);
  digitalWrite(motorB_IN1, HIGH);
  digitalWrite(motorB_IN2, LOW);
  setSpeedClamped(pwmA, pwmB);
}

void backward() {
  digitalWrite(motorA_IN1, LOW);
  digitalWrite(motorA_IN2, HIGH);
  digitalWrite(motorB_IN1, LOW);
  digitalWrite(motorB_IN2, HIGH);
  setSpeedClamped(pwmA, pwmB);
}

void stopMotors() {
  digitalWrite(motorA_IN1, LOW);
  digitalWrite(motorA_IN2, LOW);
  digitalWrite(motorB_IN1, LOW);
  digitalWrite(motorB_IN2, LOW);
  setSpeedClamped(0, 0);
}

// 3-Pin-Lenkung mit Serial-Ausgabe
void steer_right(){
  digitalWrite(servoPin1, HIGH);
  digitalWrite(servoPin2, LOW);
  digitalWrite(servoPin3, LOW);

  Serial.println("Lenkung: RECHTS");
}
void steer_left(){
  digitalWrite(servoPin1, LOW);
  digitalWrite(servoPin2, HIGH);
  digitalWrite(servoPin3, LOW);

  Serial.println("Lenkung: LINKS");
}
void steer_straight(){
  digitalWrite(servoPin1, LOW);
  digitalWrite(servoPin2, LOW);
  digitalWrite(servoPin3, HIGH);

  Serial.println("Lenkung: GERADEAUS");
}

// ---- magnetometer ----
#define MPU_ADDR      0x68
#define HMC5883_ADDR  0x1E   // Kompass-Adresse

// --- Magnet-Offsets / Soft-Iron aus Kalibrierung ---
float magOffsetX = 107.5f;
float magOffsetY = 111.5f;
float magOffsetZ = -459.0f;

// Soft-Iron-Skalen aus Kalibrierung
float scaleX = 295.5f;
float scaleY = 295.5f;
float scaleZ = 20.0f;      // Z wird nur mit Offset genutzt
float avgScaleXY = (295.5f + 295.5f) * 0.5f;  // = 295.5f

// --- Deklination für deinen Standort ---
const float declinationDeg = 1.35f;
const float declinationRad = declinationDeg * PI / 180.0f;

// --- zusätzlicher Heading-Offset, um das Board zur Welt auszurichten ---
// Erstmal 0, später fein einstellen (z.B. -5.0f), wenn Nord leicht daneben liegt
float headingOffsetDeg = 82.0f;   // so gedreht, dass 286° → 0° (Norden)

// --- Filter für geglättetes Heading ---
float headingFiltered = 0.0f;
bool  headingInit     = false;

// === globaler Heading-Wert in Grad (0..360) ===
float headingDegGlobal = 0.0f;

void enableBypass();
void initHMC5883L();
bool readHMC5883L(int16_t &x, int16_t &y, int16_t &z);
bool readMPUAccel(float &ax, float &ay, float &az);
const char* headingToDirection(float deg);
float normalize360(float a);
void printOrientation();
void controlHeadingForState();


float angleDiffDeg(float target, float current) {
  float diff = target - current;  // positiver Wert = Ziel liegt „rechts“ (im Uhrzeigersinn)

  while (diff > 180.0f)  diff -= 360.0f;
  while (diff < -180.0f) diff += 360.0f;

  return diff;
}

void setup() {
  Serial.begin(115200);
  delay(1000);

  // Motoren (PWM + DIR)
  pinMode(motorA_IN1, OUTPUT);
  pinMode(motorA_IN2, OUTPUT);
  pinMode(motorB_IN1, OUTPUT);
  pinMode(motorB_IN2, OUTPUT);
  ledcAttach(motorA_EN, freqPWM, resPWM);
  ledcAttach(motorB_EN, freqPWM, resPWM);
  ledcWrite(motorA_EN, 0);
  ledcWrite(motorB_EN, 0);

  // Servo (3-Pin)
  pinMode(servoPin1, OUTPUT);
  pinMode(servoPin2, OUTPUT);
  pinMode(servoPin3, OUTPUT);
  steer_straight();

    // Encoder
  ESP32Encoder::useInternalWeakPullResistors = puType::up;
  encA.attachFullQuad(ENCA_1, ENCA_2);
  encB.attachFullQuad(ENCB_1, ENCB_2);
  encA.clearCount();
  encB.clearCount();

  // GPS

  // ---- magnetometer ----
  Wire.begin(21, 22);

  enableBypass();
  Serial.println("MPU6050 Bypass aktiviert.");

  initHMC5883L();
  Serial.println("HMC5883L initialisiert.");
  // ---- magnetometer ----
}

void loop() {  
    // Automatikmodus: immer vorwärts fahren
  forward();
  static uint32_t t0 = 0;

  if (millis() - t0 > 200) {
    t0 = millis();
    cA = encA.getCount();
    cB = encB.getCount();
    Serial.print("EncA: ");
    Serial.print((long long)cA);
    Serial.print(" EncB: ");
    Serial.println((long long)cB);
  }
  

  if (cA >= 110000) {
    Serial.println("Segment fertig, nächster State");
    if (state < 3) {
      state++;
      encA.clearCount();
      encB.clearCount();
      cA = 0;
      cB = 0;
    } else {
      state = 0;
      encA.clearCount();
      encB.clearCount();
      cA = 0;        
      cB = 0;
      }
      
  }


  Serial.print("stage  ");
  Serial.println(state);

  // 1) Kompass / Lage ausgeben + headingDegGlobal aktualisieren
  printOrientation();

  // 2) Lenkung anhand Kompass und State (Nord/Ost/Süd/West)
  controlHeadingForState();
  
  delay(200);
}

// ---- magnetometer ----
void enableBypass() {
  // MPU aufwecken
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(0x6B);   // PWR_MGMT_1
  Wire.write(0x00);   // Sleep aus
  Wire.endTransmission();

  // I2C-Master im MPU ausschalten
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(0x6A);   // USER_CTRL
  Wire.write(0x00);   // I2C_MST_EN = 0
  Wire.endTransmission();

  // Bypass-Modus aktivieren
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(0x37);   // INT_PIN_CFG
  Wire.write(0x02);   // I2C_BYPASS_EN = 1
  Wire.endTransmission();

  // Accelerometer ±2g
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(0x1C);   // ACCEL_CONFIG
  Wire.write(0x00);   // ±2g
  Wire.endTransmission();
}


void initHMC5883L() {
  // Config A: 8-fach Mittelung, 15 Hz
  Wire.beginTransmission(HMC5883_ADDR);
  Wire.write(0x00);
  Wire.write(0x70);
  Wire.endTransmission();

  // Config B: Gain
  Wire.beginTransmission(HMC5883_ADDR);
  Wire.write(0x01);
  Wire.write(0x20);   // 1.3 Gauss
  Wire.endTransmission();

  // Mode: Continuous
  Wire.beginTransmission(HMC5883_ADDR);
  Wire.write(0x02);
  Wire.write(0x00);
  Wire.endTransmission();
}


bool readHMC5883L(int16_t &x, int16_t &y, int16_t &z) {
  Wire.beginTransmission(HMC5883_ADDR);
  Wire.write(0x03);       // X_MSB
  if (Wire.endTransmission() != 0) return false;

  Wire.requestFrom(HMC5883_ADDR, 6);
  if (Wire.available() < 6) return false;

  uint8_t x_msb = Wire.read();
  uint8_t x_lsb = Wire.read();
  uint8_t z_msb = Wire.read();
  uint8_t z_lsb = Wire.read();
  uint8_t y_msb = Wire.read();
  uint8_t y_lsb = Wire.read();

  x = (int16_t)((x_msb << 8) | x_lsb);
  z = (int16_t)((z_msb << 8) | z_lsb);
  y = (int16_t)((y_msb << 8) | y_lsb);

  return true;
}

bool readMPUAccel(float &ax, float &ay, float &az) {
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(0x3B);  // ACCEL_XOUT_H
  if (Wire.endTransmission(false) != 0) {
    return false;
  }

  Wire.requestFrom(MPU_ADDR, 6, true);
  if (Wire.available() < 6) {
    return false;
  }

  int16_t ax_raw = (Wire.read() << 8) | Wire.read();
  int16_t ay_raw = (Wire.read() << 8) | Wire.read();
  int16_t az_raw = (Wire.read() << 8) | Wire.read();

  ax = (float)ax_raw;
  ay = (float)ay_raw;
  az = (float)az_raw;

  return true;
}


const char* headingToDirection(float deg) {
  int sector = (int)((deg + 22.5f) / 45.0f) % 8;

  switch (sector) {
    case 0: return "N";
    case 1: return "NE";
    case 2: return "E";
    case 3: return "SE";
    case 4: return "S";
    case 5: return "SW";
    case 6: return "W";
    case 7: return "NW";
  }
  return "?";
}


float normalize360(float a) {
  while (a < 0.0f)     a += 360.0f;
  while (a >= 360.0f)  a -= 360.0f;
  return a;
}


void printOrientation() {
  // --- 1) Beschleunigung -> Pitch & Roll ---
  float ax, ay, az;
  if (!readMPUAccel(ax, ay, az)) {
    Serial.println("Fehler beim Lesen des MPU6050!");
    return;
  }

  // in g umrechnen (±2g -> 16384 LSB/g)
  ax /= 16384.0f;
  ay /= 16384.0f;
  az /= 16384.0f;

  float roll  = atan2(ay, az);
  float pitch = atan2(-ax, sqrt(ay * ay + az * az));

  int16_t mx_raw, my_raw, mz_raw;
  if (!readHMC5883L(mx_raw, my_raw, mz_raw)) {
    Serial.println("Fehler beim Lesen vom HMC5883L!");
    return;
  }

  // Rohwerte als float
  float mx_f = (float)mx_raw;
  float my_f = (float)my_raw;
  float mz_f = (float)mz_raw;

  // --- Hard-Iron + Soft-Iron fuer X/Y, nur Hard-Iron fuer Z ---
  // X und Y auf gemeinsamen Radius bringen
  float mx = (mx_f - magOffsetX) * (avgScaleXY / scaleX);  // scaleX ~ 295.5
  float my = (my_f - magOffsetY) * (avgScaleXY / scaleY);  // scaleY ~ 295.5

  // Z: nur Offset, keine aggressive Skalierung (scaleZ ist sehr klein/unsicher)
  float mz = (mz_f - magOffsetZ);

  // --- 3) Tilt-Kompensation ---
  float cosPitch = cos(pitch);
  float sinPitch = sin(pitch);
  float cosRoll  = cos(roll);
  float sinRoll  = sin(roll);

  float Xh = mx * cosPitch + mz * sinPitch;
  float Yh = mx * sinRoll * sinPitch + my * cosRoll - mz * sinRoll * cosPitch;

  float heading = atan2(Yh, Xh);  // Radiant

  // Deklination berücksichtigen
  heading += declinationRad;

  // auf 0..2PI normalisieren
  if (heading < 0)      heading += 2 * PI;
  if (heading > 2 * PI) heading -= 2 * PI;

  float headingDeg = heading * 180.0f / PI;

  // --- 4) zusätzlichen, festen Offset einrechnen (Sensor-Lage im Gehäuse) ---
  headingDeg += headingOffsetDeg;

  // --- 5) Heading glätten ---
  float newHeading = normalize360(headingDeg);

  if (!headingInit) {
    headingFiltered = newHeading;
    headingInit = true;
  } else {
    // Differenz korrekt über 0/360 behandeln
    float diff = newHeading - headingFiltered;
    if (diff > 180.0f)  diff -= 360.0f;
    if (diff < -180.0f) diff += 360.0f;

    float alpha = 0.2f;  // 0.1 = sehr weich, 0.3 = schneller
    headingFiltered += alpha * diff;
  }

  float headingDegFilt = normalize360(headingFiltered);
  float pitchDeg       = pitch * 180.0f / PI;
  float rollDeg        = roll  * 180.0f / PI;

  const char* dir = headingToDirection(headingDegFilt);

  // === globalen Heading-Wert setzen ===
  headingDegGlobal = headingDegFilt;

  // --- Ausgabe ---
  Serial.print("Pitch: ");
  Serial.print(pitchDeg, 1);
  Serial.print("°  Roll: ");
  Serial.print(rollDeg, 1);
  Serial.print("°  Heading: ");
  Serial.print(headingDegFilt, 1);
  Serial.print("°  Richtung: ");
  Serial.println(dir);
}

// ----------------------------------------------------------
// Heading-Regler je nach State (N, O, S, W) mit ±10° Fenster
// nutzt jetzt angleDiffDeg() und vermeidet 0/360-Sprünge
// ----------------------------------------------------------
void controlHeadingForState() {
  float targetDeg = 0.0f;
  switch (state) {
    case 0: targetDeg = 355.3f;   break;   // Norden
    case 1: targetDeg = 86.0f;  break;   // Osten
    case 2: targetDeg = 188.6f; break;   // Süden
    case 3: targetDeg = 282.1f; break;   // Westen
    default: targetDeg = 0.0f;  break;
  }

  float current = headingDegGlobal;
  float err = angleDiffDeg(targetDeg, current);

  Serial.print("Target: ");
  Serial.print(targetDeg);
  Serial.print("  Current: ");
  Serial.print(current);
  Serial.print("  Err: ");
  Serial.println(err);

  const float deadband = 10.0f;

  if (fabs(err) <= deadband) {
    steer_straight();
  }
  else if (err > 0) {
    steer_right(); 
  }
  else { 
    steer_left();
  }
}



